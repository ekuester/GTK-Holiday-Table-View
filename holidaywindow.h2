/* 
 * File:   holidaywindow.h
 * Author: kuestere
 *
 * Created on 16. Juni 2018, 15:45
 */

#ifndef HOLIDAYWINDOW_H
#define HOLIDAYWINDOW_H

#include <cstdlib>
#include <ctime>
#include <gtkmm/messagedialog.h>
#include <iomanip>
#include <iostream>
#include <limits>
#include <locale>
#include <sstream>
#include <string>
#include <gtkmm-3.0/gtkmm/label.h>
#include <gtkmm-3.0/gtkmm/entry.h>
#include <gtkmm-3.0/gtkmm/scrolledwindow.h>

using namespace std;

class Holiday; // Say Holiday exists without defining it.

class HolidayWindow : public Gtk::Window {
public:
    HolidayWindow();
    virtual ~HolidayWindow();
protected:
    guint get_yearnumber();

    //Signal handlers
    void on_activated();
    void on_button_quit();

    // gregorian day (days since March 1, 800 ante Chr.)
    // implements a proleptic Gregorian calendar
    // see <http://howardhinnant.github.io/date_algorithms.html>
    // 719468 is gregorian day for January 1, 1970 (unix epoch date)

    class Gregorian {
    public:
        // Default constructor: today's date as gregorian day
        Gregorian() {
            time_t seconds = time(0);
            gregorian = 719468.0 + seconds / 86400;
            date();
        }
/*
        // valid only for gregorian calendar
        // March 1, year as gregorian day as base for easter sunday
        Gregorian (int y) {
            year = y;
            month = 3;
            day = 1;
            is_leap = y % 4 == 0 && (y % 100 != 0 || y % 400 == 0);
            y -= month <= 2;
            int era = (y >= 0 ? y : y - 399) / 400;
            unsigned yoe = static_cast<unsigned>(y - era * 400);          // [0, 399]
            unsigned doy = 
                (153 * (month + (month > 2 ? -3 : 9)) + 2) / 5 + day - 1; // [0, 365]
            unsigned doe = yoe * 365 + yoe / 4 - yoe / 100 + doy;         // [0, 146096]
            gregorian = era * 146097.0 + doe;
       }
 */
        Gregorian(int y, unsigned m, unsigned d) {
            year = y;
            month = m;
            day = d;
            is_leap = y % 4 == 0 && (y % 100 != 0 || y % 400 == 0);
            y -= m <= 2;
            int era = (y >= 0 ? y : y - 399) / 400;
            unsigned yoe = static_cast<unsigned>(y - era * 400);         // [0, 399]
            unsigned doy = (153 * (m + (m > 2 ? -3 : 9)) + 2) / 5 + d-1; // [0, 365]
            unsigned doe = yoe * 365 + yoe / 4 - yoe / 100 + doy;        // [0, 146096]
            gregorian = era * 146097.0 + doe;
        }

        operator double() const {
            return this->gregorian;
        }

        // subtract two gregorian numbers
        double operator-(const Gregorian &other) const {
            return this->gregorian - other.gregorian;
        }

        // substract constant from gregorian number
        double operator-(const double days) const {
            return this->gregorian - days;
        }

        bool is_leap;
        int year;
        unsigned month, day;

        Gregorian easter(int year) {
           /*
            * Ostern faellt auf den Sonntag nach dem ersten Vollmond im Fruehling
            * Carl Friedrich Gauß (1777 - 1855) hat aus den langen und schwer verstaendlichen
            * Texten von Christophorus Clavius eine praktische Rechenvorschrift abgeleitet.
            * Diese wird in einer von Dr. Heiner Lichtenberg, Bonn, modifizierten Form angegeben.
            * H. Lichtenberg, Zur Interpretation der Gaussschen Osterformel und ihrer Ausnahmeregeln,
            * Historia Mathematica 24, 441 - 444 (1997).
            * siehe insbesondere
            * <https://de.wikipedia.org/wiki/Gau%C3%9Fsche_Osterformel> sowie
            * <http://www.ptb.de/cms/ptb/fachabteilungen/abt4/fb-44/ag-441/darstellung-der-gesetzlichen-zeit/wann-ist-ostern.html>
            *  1. die Säkularzahl:				K = X div 100
            *  2. die säkulare Mondschaltung:                   M = 15 + (3K + 3) div 4 − (8K + 13) div 25
            *  3. die säkulare Sonnenschaltung:                 S = 2 − (3K + 3) div 4
            *  4. den Mondparameter:                            A = X mod 19
            *  5. den Keim für den ersten Frühlingsvollmond:    D = (19A + M) mod 30
            *  6. die kalendarische Korrekturgröße:             R = D div 29 + (D div 28 − D div 29) (A div 11)
            *  7. die Ostergrenze:                             OG = 21 + D − R
            *  8. den ersten Sonntag im März:                  SZ = 7 − (X + X div 4 + S) mod 7
            *  9. die Entfernung des Ostersonntags von der
            *     Ostergrenze (Osterentfernung in Tagen):      OE = 7 − (OG − SZ) mod 7
            * 10. das Datum des Ostersonntags als Maerzdatum   OS = OG + OE
            * OG ist das Maerzdatum des Ostervollmonds. Dies entspricht dem 14. Tag
            * des ersten Monats im Mondkalender, genannt Nisanu.
            * SZ ist das Datum des ersten Sonntags im Maerz.
            * OS = OG + OE ist das Datum des Ostersonntags, als Datum im Monat Maerz dargestellt.
            * Der 32. Maerz entspricht also dem 1. April, usw.
            */
            int k = year / 100;
            int m = 15 + (3 * k + 3) / 4 - (8 * k + 13) / 25;
            int s = 2 - (3 * k + 3) / 4;
            int a = year % 19;
            int d = (19 * a + m) % 30;
            int r = d / 29 + (d / 28 - d / 29) * (a / 11);
            int og = 21 + d - r;
            int sz = 7 - (year + year / 4 + s) % 7;
            int oe = 7 - (og - sz) % 7;
            unsigned os = og + oe;
            unsigned om = 3;
            if (os > 31) {
                om += 1;
                os -= 31;
            }
            return Gregorian(year, om, os);
        }
 
        void date() {
            // compute year, month, day from date
            const int era = (gregorian >= 0 ? gregorian : gregorian - 146096) / 146097;
            const unsigned doe = static_cast<unsigned> (gregorian - era * 146097); // [0, 146096]
            const unsigned yoe = (doe - doe / 1460 + doe / 36524 - doe / 146096) / 365; // [0, 399]
            int y = static_cast<int> (yoe) + era * 400;
            const unsigned doy = doe - (365 * yoe + yoe / 4 - yoe / 100); // [0, 365]
            const unsigned mp = (5 * doy + 2) / 153; // [0, 11]
            day = doy - (153 * mp + 2) / 5 + 1; // [1, 31]
         // d = f(m) = (306 * m + 5) / 10
            month = mp + (mp < 10 ? 3 : -9); // [1, 12]
            y += (month <= 2);
            is_leap = y % 4 == 0 && (y % 100 != 0 || y % 400 == 0);
            year = y;
        }

    private:
        double gregorian;
    };

    // Child widgets
    Gtk::Box m_HBoxTop;
    Gtk::Label m_Label;
    Gtk::Entry m_Text;

    Gtk::Box m_VBox;
    Gtk::ScrolledWindow m_ScrolledWindow;
    //    Gtk::TreeView m_TreeView;
    //    Glib::RefPtr<Gtk::ListStore> m_refTreeModel;
    Gtk::Box m_HBoxBottom;
    Gtk::ButtonBox m_SaveButtonBox;
    Gtk::Button m_ButtonSave;
    Gtk::ButtonBox m_ButtonBox;
    Gtk::Button m_ButtonQuit;
};

#endif /* HOLIDAYWINDOW_H */
